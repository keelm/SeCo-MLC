/*
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * IRuleRefiner.java Copyright (C) 2003-2010 Knowledge Engineering Group http://www.ke.tu-darmstadt.de
 *
 * Added by Matthias Thiel Created on 30.10.2004, 12:09
 */

package de.tu_darmstadt.ke.seco.algorithm.components.rulerefiners;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.Set;
import java.util.TreeSet;

import de.tu_darmstadt.ke.seco.models.SingleHeadRule;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import weka.core.Instance;
import de.tu_darmstadt.ke.seco.algorithm.components.SeCoComponent;
import de.tu_darmstadt.ke.seco.algorithm.components.heuristics.Heuristic;
import de.tu_darmstadt.ke.seco.models.Instances;
import de.tu_darmstadt.ke.seco.models.SingleHeadRuleSet;
import de.tu_darmstadt.ke.seco.stats.TwoClassConfusionMatrix;
import de.tu_darmstadt.ke.seco.utils.TicksPerSecondCounter;

/**
 * Interface for a rule refiner.
 *
 * @author Knowledge Engineering Group
 */

public abstract class RuleRefiner extends SeCoComponent {

	private static final long serialVersionUID = -4395084302773342870L;

	// TODO by m.zopf: should not be needed in the refiner. move rule evaluation to the rule!
	protected Heuristic heuristic;

	/**
	 * Stores already generated rules.
	 */

	private final Set<SingleHeadRule> alreadyGeneratedRules = new TreeSet<SingleHeadRule>(Collections.reverseOrder());

	/**
	 * If already generated rules should be regenerated by the refiner.
	 */
	private boolean regenerateAlreadyGeneratedRules = true;

	private Set<SingleHeadRule> refinements = new TreeSet<SingleHeadRule>(Collections.reverseOrder());

	protected Integer beamwidth;

	/**
	 * This will create a set of rules that have been refined from the given CandidateRule.
	 *
	 * @param c
	 *            The CandidateRule that is to be refined.
	 * @param examples
	 *            The training set.
	 * @return a set of refinements
	 * @throws Exception
	 */
	public abstract SingleHeadRuleSet refineRule(SingleHeadRule c, Instances examples, double classValue) throws Exception;

	// TODO by m.zopf: this method is already implemented in SingleHeadRule and should be reused
	protected void evaluateRule(final SingleHeadRule r, final Instances examples, final double classValue) throws Exception {
		double tp = 0;
		double fp = 0;
		double tn = 0;
		double fn = 0;

		for (int i = 0; i < examples.numInstances(); i++) {
			final Instance inst = examples.instance(i);
			final double w = inst.weight();
			int counterCase = 0;
			TicksPerSecondCounter.globalTicksPerSecondCounter.tick();
			if (!r.covers(inst))
				counterCase += 2;
			if (inst.classValue() != classValue)
				counterCase++;
			switch (counterCase) {
				case 0:
					tp += w;
					break;
				case 1:
					fp += w;
					break;
				case 2:
					fn += w;
					break;
				case 3:
					tn += w;
					break;
			}
		}
		final TwoClassConfusionMatrix tcs = new TwoClassConfusionMatrix(tp, fn, fp, tn);
		r.setStats(tcs);
		r.computeRuleValue(heuristic);

		// System.out.println("evaluated rule: " + r);S
	}

	/**
	 * Convert the given set of CandidateRules into a SingleHeadRuleSet
	 *
	 * @return a SingleHeadRuleSet containing all rules from the given set
	 */
	protected SingleHeadRuleSet getRefinementsAsRuleSet() {
		final SingleHeadRuleSet ruleSet = new SingleHeadRuleSet();

		for (final SingleHeadRule rule : refinements)
			ruleSet.addRule(rule);

		return ruleSet;
	}

	@Override
	public void setProperty(final String name, final String value) {
		if (name.equalsIgnoreCase("beamwidth") && value != null)
			this.beamwidth = Integer.parseInt(value);
			// refinements = new BestRefinements(beamwidth);
		else if (name.equalsIgnoreCase("regeneratedAlreadyGeneratedRules"))
			regenerateAlreadyGeneratedRules = Boolean.parseBoolean(value);

	}

	public void clearAlreadyGeneratedRules() {
		alreadyGeneratedRules.clear();
	}

	protected void clearRefinements() {
		refinements.clear();
	}

	protected void addToRefinements(final SingleHeadRule candidateRule) {
		// if (!regenerateAlreadyGeneratedRules) {
		// if (!alreadyGeneratedRules.contains(candidateRule)) {
		// alreadyGeneratedRules.add(candidateRule);
		// refinements.add(candidateRule);
		// }
		// }
		// else {
		// if (!alreadyGeneratedRules.contains(candidateRule))
		// alreadyGeneratedRules.add(candidateRule);
		// refinements.add(candidateRule);
		// }
		refinements.add(candidateRule);
	}

	@Override
	public String toString() {
		return (new ReflectionToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE) {
			@Override
			protected boolean accept(final Field f) {
				return super.accept(f) && !(f.getName().equals("alreadyGeneratedRules") || f.getName().equals("refinements") || f.getName().equals("regenerateAlreadyGeneratedRules") || f.getName().equals("heuristic") || f.getName().equals("beamwidth")); // exclude some fields from the toString
			}
		}).toString();
	}
}
